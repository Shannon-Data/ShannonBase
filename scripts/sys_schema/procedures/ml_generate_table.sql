-- Copyright (c) 2014, 2023, Oracle and/or its affiliates.
--
-- This program is free software; you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; version 2 of the License.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program; if not, write to the Free Software
-- Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
-- Copyright (c) 2023, Shannon Data AI and/or its affiliates.

DROP PROCEDURE IF EXISTS ml_generate_table;

DELIMITER $$

CREATE DEFINER='mysql.sys'@'localhost' PROCEDURE ml_generate_table (
        in input_table_column  varchar(256),
        in output_table_column  VARCHAR(256),
        in options JSON
    )
    COMMENT '
Description
-----------
The ML_GENERATE_TABLE routine runs multiple text generation or summarization queries in a batch, in parallel. 
The output generated for every input query is the same as the output generated by the ML_GENERATE routine.
Parameters
-----------
in_input_table_column (VARCHAR(255)):
  Specifies the input database, table, and column in format: DBName.TableName.ColumnName
  
in_output_table_column (VARCHAR(255)):
  Specifies the output database, table, and column in format: DBName.TableName.ColumnName

in_options (JSON):
  options: specifies optional parameters as key-value pairs in JSON format. It can include the following parameters::
  - task: specifies the task expected from the large language model (LLM). Default value is generation.generation,summarization
  - model_id: specifies the LLM to use for the task.llama3.2-3b-instruct-v1, etc.
  - context_column: specifies the table column that contains the context to be used for augmenting the queries and guiding the text generation of the LLM. The specified column must be an existing column in the input table. Default value is NULL.
  - language: specifies the language to be used for writing queries, ingesting documents, and generating the output. 
  - temperature: specifies a non-negative float that tunes the degree of randomness in generation. Lower temperatures mean less random generations.
  - max_tokens: specifies the maximum number of tokens to predict per generation using an estimate of three tokens per word. Default value is 256. 
  - top_k: specifies the number of top most likely tokens to consider for text generation at each step. Default value is 40, which means that top 40 most likely tokens are considered for text generation at each step. Possible values are integer values between 0 and 32000.
  - top_p: specifies a number, p, and ensures that only the most likely tokens with the sum of probabilities p are considered for generation at each step. A higher value of p introduces more randomness into the output.
  - repeat_penalty: assigns a penalty when a token appears repeatedly. High penalties encourage less repeated tokens and produce more random outputs. Default value is 1.1. Possible values are float values between 0 and 2.
  - frequency_penalty: assigns a penalty when a token appears frequently. High penalties encourage less repeated tokens and produce more random outputs. Default value is 0. Possible values are float values between 0 and 1.
  - presence_penalty: assigns a penalty to each token when it appears in the output to encourage generating outputs with tokens that haven\'t been used. This is similar to frequency_penalty, except that this penalty is applied equally to all tokens that have already appeared, irrespective of their exact frequencies.
  - stop_sequences: specifies a list of characters such as a word, a phrase, a newline, or a period that tells the LLM when to end the generated output. If you have more than one stop sequence, then the LLM stops when it reaches any of those sequences. Default value is NULL.
  - batch_size: specifies the batch size for the routine. This parameter is supported for internal tables only. Default value is 1000. Possible values are integer values between 1 and 1000.
  - speculative_decoding: enables or disables speculative decoding when generating tokens with an LLM. If set to true, speculative decoding enables faster response token generation, which speeds up LLM text generation. Speculative decoding is supported for the llama3.1-8b-instruct-v1 LLM, which uses llama3.2-1B-instruct-v1 as the draft LLM. Default value is true.
  - image_column: specifies the name of the column in the input table where the the base64 encoding of images are stored.

Example
-----------
mysql> CALL sys.ML_GENERATE_TABLE("demo_db.input_table.Input", "demo_db.output_table.Output", JSON_OBJECT("task", "generation", "model_id", "mistral-7b-instruct-v3", "language", "en"));
    '
SQL SECURITY INVOKER
DETERMINISTIC
CONTAINS SQL
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE batch_counter INT DEFAULT 0;
    DECLARE current_batch_size INT DEFAULT 1000;
    DECLARE total_rows INT DEFAULT 0;
    DECLARE processed_rows INT DEFAULT 0;
    
    -- Parameter parsing variables
    DECLARE input_db VARCHAR(64);
    DECLARE input_table VARCHAR(64);
    DECLARE input_column VARCHAR(64);
    DECLARE output_db VARCHAR(64);
    DECLARE output_table VARCHAR(64);
    DECLARE output_column VARCHAR(64);
    DECLARE context_col VARCHAR(64) DEFAULT NULL;
    DECLARE image_col VARCHAR(64) DEFAULT NULL;
    
    -- LLM configuration parameters
    DECLARE task_type VARCHAR(32) DEFAULT 'generation';
    DECLARE model_id VARCHAR(128) DEFAULT 'llama3.2-3b-instruct-v1';
    DECLARE language_code VARCHAR(8) DEFAULT 'en';
    DECLARE temperature_val DECIMAL(5,2) DEFAULT 0.0;
    DECLARE max_tokens_val INT DEFAULT 256;
    DECLARE top_k_val INT DEFAULT 40;
    DECLARE top_p_val DECIMAL(5,2) DEFAULT 0.95;
    DECLARE repeat_penalty_val DECIMAL(5,2) DEFAULT 1.1;
    DECLARE frequency_penalty_val DECIMAL(5,2) DEFAULT 0.0;
    DECLARE presence_penalty_val DECIMAL(5,2) DEFAULT 0.0;
    DECLARE stop_sequences_val JSON DEFAULT NULL;
    DECLARE batch_size_val INT DEFAULT 1000;
    DECLARE speculative_decoding_val BOOLEAN DEFAULT TRUE;
    
    -- ML_MODEL_GENERATE option JSON
    DECLARE model_options JSON DEFAULT NULL;
    
    -- Dynamic SQL variables
    DECLARE sql_stmt TEXT DEFAULT '';
    DECLARE create_table_sql TEXT DEFAULT '';
    DECLARE insert_sql TEXT DEFAULT '';
    DECLARE select_sql TEXT DEFAULT '';
    
    -- Exception handling
    DECLARE EXIT HANDLER FOR SQLEXCEPTION
    BEGIN
        ROLLBACK;
        GET DIAGNOSTICS CONDITION 1
            @p1 = RETURNED_SQLSTATE, @p2 = MESSAGE_TEXT;
        SELECT CONCAT('Error: ', @p1, ' - ', @p2) AS error_message;
        RESIGNAL;
    END;

    -- Start transaction
    START TRANSACTION;

    -- 1. Parse input and output table column names
    SET input_db = SUBSTRING_INDEX(input_table_column, '.', 1);
    SET input_table = SUBSTRING_INDEX(SUBSTRING_INDEX(input_table_column, '.', 2), '.', -1);
    SET input_column = SUBSTRING_INDEX(input_table_column, '.', -1);
    
    SET output_db = SUBSTRING_INDEX(output_table_column, '.', 1);
    SET output_table = SUBSTRING_INDEX(SUBSTRING_INDEX(output_table_column, '.', 2), '.', -1);
    SET output_column = SUBSTRING_INDEX(output_table_column, '.', -1);

    -- 2. Parse configuration parameters
    IF options IS NOT NULL THEN
        SET task_type = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(options, '$.task')), task_type);
        SET model_id = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(options, '$.model_id')), model_id);
        SET context_col = JSON_UNQUOTE(JSON_EXTRACT(options, '$.context_column'));
        SET language_code = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(options, '$.language')), language_code);
        SET temperature_val = COALESCE(JSON_EXTRACT(options, '$.temperature'), temperature_val);
        SET max_tokens_val = COALESCE(JSON_EXTRACT(options, '$.max_tokens'), max_tokens_val);
        SET top_k_val = COALESCE(JSON_EXTRACT(options, '$.top_k'), top_k_val);
        SET top_p_val = COALESCE(JSON_EXTRACT(options, '$.top_p'), top_p_val);
        SET repeat_penalty_val = COALESCE(JSON_EXTRACT(options, '$.repeat_penalty'), repeat_penalty_val);
        SET frequency_penalty_val = COALESCE(JSON_EXTRACT(options, '$.frequency_penalty'), frequency_penalty_val);
        SET presence_penalty_val = COALESCE(JSON_EXTRACT(options, '$.presence_penalty'), presence_penalty_val);
        SET stop_sequences_val = JSON_EXTRACT(options, '$.stop_sequences');
        SET batch_size_val = COALESCE(JSON_EXTRACT(options, '$.batch_size'), batch_size_val);
        SET speculative_decoding_val = COALESCE(JSON_EXTRACT(options, '$.speculative_decoding'), speculative_decoding_val);
        SET image_col = JSON_UNQUOTE(JSON_EXTRACT(options, '$.image_column'));
    END IF;

    SET current_batch_size = batch_size_val;

    -- 3. Build ML_MODEL_GENERATE options JSON
    SET model_options = JSON_OBJECT(
        'task', task_type,
        'model_id', model_id,
        'language', language_code,
        'temperature', temperature_val,
        'max_tokens', max_tokens_val,
        'top_k', top_k_val,
        'top_p', top_p_val,
        'repeat_penalty', repeat_penalty_val,
        'frequency_penalty', frequency_penalty_val,
        'presence_penalty', presence_penalty_val,
        'speculative_decoding', speculative_decoding_val
    );

    -- Add stop_sequences if provided
    IF stop_sequences_val IS NOT NULL THEN
        SET model_options = JSON_SET(model_options, '$.stop_sequences', stop_sequences_val);
    END IF;

    -- 4. Validate input table and column existence
    SET @table_exists = 0;
    SET @sql_stmt = CONCAT(
        'SELECT COUNT(*) INTO @table_exists FROM information_schema.tables ',
        'WHERE table_schema = "', input_db, '" AND table_name = "', input_table, '"'
    );
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    IF @table_exists = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Input table does not exist';
    END IF;

    -- Validate input column exists
    SET @column_exists = 0;
    SET @sql_stmt = CONCAT(
        'SELECT COUNT(*) INTO @column_exists FROM information_schema.columns ',
        'WHERE table_schema = "', input_db, '" AND table_name = "', input_table, '" AND column_name = "', input_column, '"'
    );
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    IF @column_exists = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Input column does not exist';
    END IF;

    -- Validate context column if specified
    IF context_col IS NOT NULL THEN
        SET @context_col_exists = 0;
        SET @sql_stmt = CONCAT(
            'SELECT COUNT(*) INTO @context_col_exists FROM information_schema.columns ',
            'WHERE table_schema = "', input_db, '" AND table_name = "', input_table, '" AND column_name = "', context_col, '"'
        );
        PREPARE stmt FROM @sql_stmt;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        IF @context_col_exists = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Context column does not exist';
        END IF;
    END IF;

    -- Validate image column if specified
    IF image_col IS NOT NULL THEN
        SET @image_col_exists = 0;
        SET @sql_stmt = CONCAT(
            'SELECT COUNT(*) INTO @image_col_exists FROM information_schema.columns ',
            'WHERE table_schema = "', input_db, '" AND table_name = "', input_table, '" AND column_name = "', image_col, '"'
        );
        PREPARE stmt FROM @sql_stmt;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
        
        IF @image_col_exists = 0 THEN
            SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Image column does not exist';
        END IF;
    END IF;

    -- 5. Check if input table has primary key
    SET @pk_exists = 0;
    SET @sql_stmt = CONCAT(
        'SELECT COUNT(*) INTO @pk_exists FROM information_schema.key_column_usage ',
        'WHERE table_schema = "', input_db, '" AND table_name = "', input_table, '" AND constraint_name = "PRIMARY"'
    );
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    
    IF @pk_exists = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Input table must have a primary key';
    END IF;

    -- 6. Get total row count
    SET @sql_stmt = CONCAT('SELECT COUNT(*) INTO @total_rows FROM `', input_db, '`.`', input_table, '` WHERE `', input_column, '` IS NOT NULL AND `', input_column, '` != ""');
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
    SET total_rows = @total_rows;

    IF total_rows = 0 THEN
        SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Input table is empty or contains no valid data';
    END IF;

    -- 7. Create or validate output table
    SET @output_table_exists = 0;
    SET @sql_stmt = CONCAT(
        'SELECT COUNT(*) INTO @output_table_exists FROM information_schema.tables ',
        'WHERE table_schema = "', output_db, '" AND table_name = "', output_table, '"'
    );
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    IF @output_table_exists = 0 THEN
        -- Create new output table
        -- First get input table's primary key structure
        SET @sql_stmt = CONCAT(
            'SELECT GROUP_CONCAT(DISTINCT ',
            'CONCAT("`", column_name, "` ", data_type, ',
            'CASE WHEN character_maximum_length IS NOT NULL THEN CONCAT("(", character_maximum_length, ")") ',
            'WHEN numeric_precision IS NOT NULL THEN CONCAT("(", numeric_precision, IFNULL(CONCAT(",", numeric_scale), ""), ")") ',
            'ELSE "" END) SEPARATOR ", ") INTO @pk_columns ',
            'FROM information_schema.columns c ',
            'JOIN information_schema.key_column_usage k ON c.table_schema = k.table_schema AND c.table_name = k.table_name AND c.column_name = k.column_name ',
            'WHERE c.table_schema = "', input_db, '" AND c.table_name = "', input_table, '" AND k.constraint_name = "PRIMARY" ',
            'ORDER BY k.ordinal_position'
        );
        PREPARE stmt FROM @sql_stmt;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;

        -- Get primary key column names for PRIMARY KEY constraint
        SET @sql_stmt = CONCAT(
            'SELECT GROUP_CONCAT(DISTINCT CONCAT("`", column_name, "`") ORDER BY ordinal_position SEPARATOR ", ") INTO @pk_names ',
            'FROM information_schema.key_column_usage ',
            'WHERE table_schema = "', input_db, '" AND table_name = "', input_table, '" AND constraint_name = "PRIMARY"'
        );
        PREPARE stmt FROM @sql_stmt;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;

        SET @create_table_sql = CONCAT(
            'CREATE TABLE `', output_db, '`.`', output_table, '` (',
            @pk_columns, ', ',
            '`', output_column, '` JSON, ',
            'PRIMARY KEY (', @pk_names, ')',
            ') ENGINE=InnoDB'
        );
        
        PREPARE stmt FROM @create_table_sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;
    ELSE
        -- Validate output table structure (if same table, check output column doesn't exist)
        IF input_db = output_db AND input_table = output_table THEN
            SET @output_column_exists = 0;
            SET @sql_stmt = CONCAT(
                'SELECT COUNT(*) INTO @output_column_exists FROM information_schema.columns ',
                'WHERE table_schema = "', output_db, '" AND table_name = "', output_table, '" AND column_name = "', output_column, '"'
            );
            PREPARE stmt FROM @sql_stmt;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;
            
            IF @output_column_exists > 0 THEN
                SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Output column already exists in the same table';
            END IF;
            
            -- Add output column
            SET @sql_stmt = CONCAT('ALTER TABLE `', output_db, '`.`', output_table, '` ADD COLUMN `', output_column, '` JSON');
            PREPARE stmt FROM @sql_stmt;
            EXECUTE stmt;
            DEALLOCATE PREPARE stmt;
        END IF;
    END IF;

    -- 8. Get primary key columns for later use
    SET @sql_stmt = CONCAT(
        'SELECT GROUP_CONCAT(DISTINCT CONCAT("`", column_name, "`") ORDER BY ordinal_position SEPARATOR ", ") INTO @pk_columns_list ',
        'FROM information_schema.key_column_usage ',
        'WHERE table_schema = "', input_db, '" AND table_name = "', input_table, '" AND constraint_name = "PRIMARY"'
    );
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    -- 9. Process data in batches
    SET batch_counter = 0;
    SET processed_rows = 0;

    -- Create temporary table to store batch results
    DROP TEMPORARY TABLE IF EXISTS temp_batch_results;
    
    -- Build temporary table creation SQL dynamically
    SET @sql_stmt = CONCAT(
        'SELECT GROUP_CONCAT(DISTINCT ',
        'CONCAT("`", column_name, "` ", data_type, ',
        'CASE WHEN character_maximum_length IS NOT NULL THEN CONCAT("(", character_maximum_length, ")") ',
        'WHEN numeric_precision IS NOT NULL THEN CONCAT("(", numeric_precision, IFNULL(CONCAT(",", numeric_scale), ""), ")") ',
        'ELSE "" END) SEPARATOR ", ") INTO @temp_pk_columns ',
        'FROM information_schema.columns c ',
        'JOIN information_schema.key_column_usage k ON c.table_schema = k.table_schema AND c.table_name = k.table_name AND c.column_name = k.column_name ',
        'WHERE c.table_schema = "', input_db, '" AND c.table_name = "', input_table, '" AND k.constraint_name = "PRIMARY" ',
        'ORDER BY k.ordinal_position'
    );
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    SET @sql_stmt = CONCAT(
        'CREATE TEMPORARY TABLE temp_batch_results (',
        'batch_id INT AUTO_INCREMENT PRIMARY KEY, ',
        @temp_pk_columns, ', ',
        'input_text TEXT, ',
        'context_text TEXT, ',
        CASE WHEN image_col IS NOT NULL THEN 'image_data LONGTEXT, ' ELSE '' END,
        'generated_output JSON, ',
        'processing_status ENUM("pending", "processed", "error") DEFAULT "pending", ',
        'error_message TEXT NULL',
        ')'
    );
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    -- Main batch processing loop
    WHILE processed_rows < total_rows DO
        SET batch_counter = batch_counter + 1;
        
        -- Clear temporary table
        TRUNCATE temp_batch_results;
        
        -- Load batch data into temporary table
        SET @select_sql = CONCAT(
            'INSERT INTO temp_batch_results (', @pk_columns_list, ', input_text, context_text',
            CASE WHEN image_col IS NOT NULL THEN ', image_data' ELSE '' END,
            ') SELECT ', @pk_columns_list, ', `', input_column, '`',
            CASE WHEN context_col IS NOT NULL THEN CONCAT(', `', context_col, '`') ELSE ', NULL' END,
            CASE WHEN image_col IS NOT NULL THEN CONCAT(', `', image_col, '`') ELSE '' END,
            ' FROM `', input_db, '`.`', input_table, '` ',
            'WHERE `', input_column, '` IS NOT NULL AND `', input_column, '` != "" ',
            'LIMIT ', current_batch_size, ' OFFSET ', processed_rows
        );
        
        PREPARE stmt FROM @select_sql;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;

        -- Get actual batch size loaded
        SELECT COUNT(*) INTO @current_batch_count FROM temp_batch_results;

        -- Process each row in the batch using ML_MODEL_GENERATE
        BEGIN
            DECLARE cur_done INT DEFAULT FALSE;
            DECLARE cur_input_text TEXT;
            DECLARE cur_context_text TEXT;
            DECLARE cur_image_data LONGTEXT;
            DECLARE cur_batch_id INT;
            DECLARE final_input_text TEXT;
            DECLARE generate_result JSON;
            DECLARE err_state VARCHAR(5);
            DECLARE err_msg TEXT;
            
            DECLARE batch_cursor CURSOR FOR 
                SELECT batch_id, input_text, context_text, 
                       CASE WHEN image_col IS NOT NULL THEN image_data ELSE NULL END
                FROM temp_batch_results 
                WHERE processing_status = 'pending';
            
            DECLARE CONTINUE HANDLER FOR NOT FOUND SET cur_done = TRUE;
            
            -- Handle ML_MODEL_GENERATE errors
            DECLARE CONTINUE HANDLER FOR SQLEXCEPTION
            BEGIN
                GET DIAGNOSTICS CONDITION 1
                    err_state = RETURNED_SQLSTATE, err_msg = MESSAGE_TEXT;
                
                UPDATE temp_batch_results 
                SET processing_status = 'error',
                    error_message = CONCAT('ML_MODEL_GENERATE Error: ', err_state, ' - ', err_msg)
                WHERE batch_id = cur_batch_id;
            END;
            
            OPEN batch_cursor;
            
            batch_loop: LOOP
                FETCH batch_cursor INTO cur_batch_id, cur_input_text, cur_context_text, cur_image_data;
                IF cur_done THEN
                    LEAVE batch_loop;
                END IF;
                
                -- Prepare input text with context if provided
                SET final_input_text = cur_input_text;
                IF cur_context_text IS NOT NULL AND cur_context_text != '' THEN
                    SET final_input_text = CONCAT('Context: ', cur_context_text, '\n\nQuery: ', cur_input_text);
                END IF;
                
                -- Handle image data if provided
                IF cur_image_data IS NOT NULL AND cur_image_data != '' THEN
                    SET model_options = JSON_SET(model_options, '$.image', cur_image_data);
                END IF;
                
                -- Call ML_MODEL_GENERATE function
                SELECT ML_MODEL_GENERATE(final_input_text, model_options) INTO generate_result;
                
                -- Update temporary table with result
                UPDATE temp_batch_results 
                SET generated_output = generate_result,
                    processing_status = 'processed'
                WHERE batch_id = cur_batch_id;
                
            END LOOP;
            
            CLOSE batch_cursor;
        END;

        -- Insert/Update results into output table
        IF input_db = output_db AND input_table = output_table THEN
            -- Same table, update existing records
            -- Build join condition for primary key columns
            SET @sql_stmt = CONCAT(
                'SELECT GROUP_CONCAT(DISTINCT CONCAT("t.`", column_name, "` = r.`", column_name, "`") ORDER BY ordinal_position SEPARATOR " AND ") INTO @join_condition ',
                'FROM information_schema.key_column_usage ',
                'WHERE table_schema = "', input_db, '" AND table_name = "', input_table, '" AND constraint_name = "PRIMARY"'
            );
            PREPARE stmt_join FROM @sql_stmt;
            EXECUTE stmt_join;
            DEALLOCATE PREPARE stmt_join;
            
            SET @sql_stmt = CONCAT(
                'UPDATE `', output_db, '`.`', output_table, '` t ',
                'JOIN temp_batch_results r ON (', @join_condition, ') ',
                'SET t.`', output_column, '` = r.generated_output ',
                'WHERE r.processing_status = "processed"'
            );
        ELSE
            -- Different table, insert new records
            SET @sql_stmt = CONCAT(
                'INSERT INTO `', output_db, '`.`', output_table, '` (',
                @pk_columns_list, ', `', output_column, '`) ',
                'SELECT ', @pk_columns_list, ', generated_output ',
                'FROM temp_batch_results ',
                'WHERE processing_status = "processed"'
            );
        END IF;
        
        PREPARE stmt FROM @sql_stmt;
        EXECUTE stmt;
        DEALLOCATE PREPARE stmt;

        -- Count processed and error records
        SELECT COUNT(*) INTO @batch_processed FROM temp_batch_results WHERE processing_status = 'processed';
        SELECT COUNT(*) INTO @batch_errors FROM temp_batch_results WHERE processing_status = 'error';

        SET processed_rows = processed_rows + @current_batch_count;
        
        -- Display progress
        SELECT CONCAT('Batch ', batch_counter, ' completed. Processed: ', 
                     LEAST(processed_rows, total_rows), '/', total_rows, ' rows. ',
                     'Success: ', @batch_processed, ', Errors: ', @batch_errors) AS progress;
        
        -- Log errors if any
        IF @batch_errors > 0 THEN
            SELECT 'Errors in batch:' as error_summary;
            SELECT batch_id, error_message FROM temp_batch_results WHERE processing_status = 'error';
        END IF;
        
    END WHILE;

    -- Get final statistics
    SET @sql_stmt = CONCAT('SELECT COUNT(*) INTO @final_count FROM `', output_db, '`.`', output_table, '` WHERE `', output_column, '` IS NOT NULL');
    PREPARE stmt FROM @sql_stmt;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;

    -- Clean up temporary table
    DROP TEMPORARY TABLE IF EXISTS temp_batch_results;

    -- Commit transaction
    COMMIT;

    -- Return result summary
    SELECT 
        'ML_GENERATE_TABLE completed successfully' AS status,
        task_type AS task,
        model_id AS model_used,
        total_rows AS total_input_rows,
        @final_count AS total_generated_rows,
        batch_counter AS total_batches,
        current_batch_size AS batch_size,
        CONCAT(output_db, '.', output_table, '.', output_column) AS output_location;

END$$

DELIMITER ;